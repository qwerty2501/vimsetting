snippet BIT
    #[allow(dead_code)]
    #[doc = " Generic Binary Indexed Tree"]
    pub struct BIT<T: Clone, F: Fn(&mut T, &T) -> ()> {
        buf: Vec<T>,
        zero: T,
        f: F,
    }
    impl<T: Clone, F: Fn(&mut T, &T) -> ()> BIT<T, F> {
        #[allow(dead_code)]
        pub fn new(n: usize, zero: &T, f: F) -> BIT<T, F> {
            BIT {
                buf: vec![zero.clone(); n + 1],
                zero: zero.clone(),
                f: f,
            }
        }
        #[allow(dead_code)]
        pub fn sum(&self, i: usize) -> T {
            let mut i = i;
            let mut s = self.zero.clone();
            while i > 0 {
                (self.f)(&mut s, &self.buf[i]);
                i &= i - 1;
            }
            s
        }
        #[allow(dead_code)]
        pub fn add(&mut self, i: usize, x: &T) {
            let mut i = i as i64;
            while i < self.buf.len() as i64 {
                let t = &mut self.buf[i as usize];
                (self.f)(t, x);
                i += i & -i;
            }
        }
    }

snippet BIT-usize
    #[allow(dead_code)]
    #[doc = " Binary Indexed Tree of usize"]
    pub struct BIT {
        buf: Vec<usize>,
    }
    #[allow(dead_code)]
    impl BIT {
        pub fn new(n: usize) -> BIT {
            BIT {
                buf: vec![0; n + 1],
            }
        }
        pub fn sum(&self, i: usize) -> usize {
            let mut i = i;
            let mut s = 0;
            while i > 0 {
                s += self.buf[i];
                i &= i - 1;
            }
            s
        }
        pub fn add(&mut self, i: usize, x: usize) {
            let mut i = i as i64;
            while i < self.buf.len() as i64 {
                self.buf[i as usize] += x;
                i += i & -i;
            }
        }
    }

snippet BinarySearch
    #[doc = " Equivalent to std::lowerbound and std::upperbound in c++"]
    pub trait BinarySearch<T> {
        fn lower_bound(&self, x: &T) -> usize;
        fn upper_bound(&self, x: &T) -> usize;
    }
    impl<T: Ord> BinarySearch<T> for [T] {
        fn lower_bound(&self, x: &T) -> usize {
            let mut low = 0;
            let mut high = self.len();
            while low != high {
                let mid = (low + high) / 2;
                match self[mid].cmp(x) {
                    Ordering::Less => {
                        low = mid + 1;
                    }
                    Ordering::Equal | Ordering::Greater => {
                        high = mid;
                    }
                }
            }
            low
        }
        fn upper_bound(&self, x: &T) -> usize {
            let mut low = 0;
            let mut high = self.len();
            while low != high {
                let mid = (low + high) / 2;
                match self[mid].cmp(x) {
                    Ordering::Less | Ordering::Equal => {
                        low = mid + 1;
                    }
                    Ordering::Greater => {
                        high = mid;
                    }
                }
            }
            low
        }
    }

snippet BitSet
    const TRUE: &'static bool = &true;
    const FALSE: &'static bool = &false;
    #[derive(Clone, Debug)]
    #[doc = " Efficient bool collection"]
    pub struct BitSet {
        buf: Vec<u64>,
        size: usize,
    }
    impl BitSet {
        #[allow(dead_code)]
        pub fn new(size: usize) -> BitSet {
            BitSet {
                buf: vec![0; (size + 63) / 64],
                size: size,
            }
        }
        #[allow(dead_code)]
        pub fn set(&mut self, i: usize, b: bool) {
            assert!(i < self.size);
            if b {
                self.buf[i >> 6] |= 1 << (i & 63);
            } else {
                self.buf[i >> 6] &= !(1 << (i & 63));
            }
        }
        #[allow(dead_code)]
        pub fn count_ones(&self) -> u32 {
            self.buf.iter().map(|x| x.count_ones()).sum()
        }
        #[allow(dead_code)]
        fn chomp(&mut self) {
            let r = self.size & 63;
            if r != 0 {
                if let Some(x) = self.buf.last_mut() {
                    let d = 64 - r;
                    *x = (*x << d) >> d;
                }
            }
        }
    }
    impl std::ops::Index<usize> for BitSet {
        type Output = bool;
        fn index(&self, index: usize) -> &bool {
            [FALSE, TRUE][(self.buf[index >> 6] >> (index & 63)) as usize & 1]
        }
    }
    impl std::ops::ShlAssign<usize> for BitSet {
        fn shl_assign(&mut self, x: usize) {
            let q = x >> 6;
            let r = x & 63;
            if q >= self.buf.len() {
                for x in &mut self.buf {
                    *x = 0;
                }
                return;
            }
            if r == 0 {
                for i in (q..self.buf.len()).rev() {
                    self.buf[i] = self.buf[i - q];
                }
            } else {
                for i in (q + 1..self.buf.len()).rev() {
                    self.buf[i] = (self.buf[i - q] << r) | (self.buf[i - q - 1] >> (64 - r));
                }
                self.buf[q] = self.buf[0] << r;
            }
            for x in &mut self.buf[..q] {
                *x = 0;
            }
            self.chomp();
        }
    }
    impl std::ops::Shl<usize> for BitSet {
        type Output = Self;
        fn shl(mut self, x: usize) -> Self {
            self <<= x;
            self
        }
    }
    impl std::ops::ShrAssign<usize> for BitSet {
        fn shr_assign(&mut self, x: usize) {
            let q = x >> 6;
            let r = x & 63;
            if q >= self.buf.len() {
                for x in &mut self.buf {
                    *x = 0;
                }
                return;
            }
            if r == 0 {
                for i in 0..self.buf.len() - q {
                    self.buf[i] = self.buf[i + q];
                }
            } else {
                for i in 0..self.buf.len() - q - 1 {
                    self.buf[i] = (self.buf[i + q] >> r) | (self.buf[i + q + 1] << (64 - r));
                }
                let len = self.buf.len();
                self.buf[len - q - 1] = self.buf[len - 1] >> r;
            }
            let len = self.buf.len();
            for x in &mut self.buf[len - q..] {
                *x = 0;
            }
        }
    }
    impl std::ops::Shr<usize> for BitSet {
        type Output = Self;
        fn shr(mut self, x: usize) -> Self {
            self >>= x;
            self
        }
    }
    impl<'a> std::ops::BitAndAssign<&'a BitSet> for BitSet {
        fn bitand_assign(&mut self, rhs: &'a Self) {
            for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {
                *a &= *b;
            }
        }
    }
    impl<'a> std::ops::BitAnd<&'a BitSet> for BitSet {
        type Output = Self;
        fn bitand(mut self, rhs: &'a Self) -> Self {
            self &= rhs;
            self
        }
    }
    impl<'a> std::ops::BitOrAssign<&'a BitSet> for BitSet {
        fn bitor_assign(&mut self, rhs: &'a Self) {
            for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {
                *a |= *b;
            }
            self.chomp();
        }
    }
    impl<'a> std::ops::BitOr<&'a BitSet> for BitSet {
        type Output = Self;
        fn bitor(mut self, rhs: &'a Self) -> Self {
            self |= rhs;
            self
        }
    }
    impl<'a> std::ops::BitXorAssign<&'a BitSet> for BitSet {
        fn bitxor_assign(&mut self, rhs: &'a Self) {
            for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {
                *a ^= *b;
            }
            self.chomp();
        }
    }
    impl<'a> std::ops::BitXor<&'a BitSet> for BitSet {
        type Output = Self;
        fn bitxor(mut self, rhs: &'a Self) -> Self {
            self ^= rhs;
            self
        }
    }

snippet Bucket
    pub struct Bucket<I: BucketImpl> {
        buf: Vec<I::Elem>,
        parent: Vec<I::Parent>,
        sqrt: usize,
        phantom_i: std::marker::PhantomData<I>,
    }
    impl<I: BucketImpl> Bucket<I>
    where
        I::Parent: Clone,
    {
        #[allow(dead_code)]
        pub fn new(init_elem: Vec<I::Elem>, init_parent: I::Parent) -> Self {
            let sqrt = (1..).find(|x| x * x >= init_elem.len()).unwrap();
            let mut parent = vec![init_parent; sqrt];
            for (i, e) in init_elem.iter().enumerate() {
                I::reduce_parent(&mut parent[i / sqrt], e);
            }
            Bucket {
                buf: init_elem,
                parent: parent,
                sqrt: sqrt,
                phantom_i: std::marker::PhantomData,
            }
        }
        #[allow(dead_code)]
        pub fn ranges(
            &self,
            l: usize,
            r: usize,
        ) -> (
            std::ops::Range<usize>,
            std::ops::Range<usize>,
            std::ops::Range<usize>,
        ) {
            if l / self.sqrt == r / self.sqrt {
                return (l..r, 0..0, 0..0);
            }
            let left = l..min((l + self.sqrt - 1) / self.sqrt * self.sqrt, r);
            let mid = (l + self.sqrt - 1) / self.sqrt..r / self.sqrt;
            let right = r / self.sqrt * self.sqrt..r;
            (left, mid, right)
        }
        #[allow(dead_code)]
        fn pe(&mut self, i: usize) -> (&mut I::Parent, &mut I::Elem) {
            (&mut self.parent[i / self.sqrt], &mut self.buf[i])
        }
        #[allow(dead_code)]
        pub fn add(&mut self, l: usize, r: usize, delta: &I::A) {
            let (left, mid, right) = self.ranges(l, r);
            for i in left.chain(right) {
                let (p, e) = self.pe(i);
                I::add(p, e, delta);
            }
            for i in mid {
                I::add_parent(&mut self.parent[i], delta);
            }
        }
        #[allow(dead_code)]
        pub fn sum(&mut self, l: usize, r: usize) -> Option<I::R> {
            let (left, mid, right) = self.ranges(l, r);
            let mut iter = left
                .chain(right)
                .map(|i| I::elem_to_result(&self.buf[i], &self.parent[i / self.sqrt]))
                .chain(mid.map(|i| I::parent_to_result(&self.parent[i])));
            if let Some(mut r) = iter.next() {
                for x in iter {
                    I::reduce_result(&mut r, &x);
                }
                Some(r)
            } else {
                None
            }
        }
    }
    pub trait BucketImpl {
        type Elem;
        type Parent;
        type A;
        type R;
        fn reduce_parent(p: &mut Self::Parent, e: &Self::Elem);
        fn add(p: &mut Self::Parent, e: &mut Self::Elem, v: &Self::A);
        fn add_parent(p: &mut Self::Parent, d: &Self::A);
        fn parent_to_result(p: &Self::Parent) -> Self::R;
        fn elem_to_result(e: &Self::Elem, p: &Self::Parent) -> Self::R;
        fn reduce_result(a: &mut Self::R, b: &Self::R);
    }

snippet Bucket-RangeAddQueryMax
    #[allow(dead_code)]
    struct RangeAddQueryMax();
    impl BucketImpl for RangeAddQueryMax {
        type Elem = u64;
        type Parent = (u64, u64);
        type A = u64;
        type R = u64;
        fn reduce_parent(p: &mut Self::Parent, e: &Self::Elem) {
            p.0 = max(p.1 + e, p.0);
        }
        fn add(p: &mut Self::Parent, e: &mut Self::Elem, v: &Self::A) {
            *e += v;
            p.0 = max(p.0, *e + p.1);
        }
        fn add_parent(p: &mut Self::Parent, d: &Self::A) {
            p.0 += d;
            p.1 += d;
        }
        fn parent_to_result(p: &Self::Parent) -> Self::R {
            p.0
        }
        fn elem_to_result(e: &Self::Elem, p: &Self::Parent) -> Self::R {
            e + p.1
        }
        fn reduce_result(a: &mut Self::R, b: &Self::R) {
            *a = max(*a, *b);
        }
    }

snippet CmpBy
    pub struct CmpBy<T, U>(T, U);
    impl<T: PartialEq, U> PartialEq for CmpBy<T, U> {
        fn eq(&self, other: &Self) -> bool {
            (self.0).eq(&other.0)
        }
    }
    impl<T: Eq, U> Eq for CmpBy<T, U> {}
    impl<T: PartialOrd, U> PartialOrd for CmpBy<T, U> {
        fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
            (self.0).partial_cmp(&other.0)
        }
    }
    impl<T: Ord, U> Ord for CmpBy<T, U> {
        fn cmp(&self, other: &Self) -> std::cmp::Ordering {
            (self.0).cmp(&other.0)
        }
    }

snippet Flow
    #[allow(dead_code)]
    #[doc = " Struct for maximum flow problem"]
    pub struct Flow {
        #[doc = " to, capacity, rev"]
        edges: Vec<Vec<(usize, usize, usize)>>,
    }
    impl Flow {
        #[allow(dead_code)]
        pub fn new(max_size: usize) -> Flow {
            Flow {
                edges: vec![Vec::new(); max_size + 1],
            }
        }
        #[allow(dead_code)]
        pub fn add_edge(&mut self, from: usize, to: usize, cap: usize) {
            let from_rev = self.edges[to].len();
            let to_rev = self.edges[from].len();
            self.edges[from].push((to, cap, from_rev));
            self.edges[to].push((from, 0, to_rev));
        }
        #[allow(dead_code)]
        #[doc = " Calculate maximum flow by dinic's algorithm"]
        pub fn max_flow_dinic(&mut self, s: usize, t: usize) -> usize {
            let mut flow = 0;
            loop {
                let level = self.bfs_dinic(s);
                let mut iter = vec![0; self.edges.len()];
                if level[t].is_none() {
                    return flow;
                }
                loop {
                    let f = self.dfs_dinic(s, t, usize::max_value(), &level, &mut iter);
                    if f == 0 {
                        break;
                    }
                    flow += f;
                }
            }
        }
        #[allow(dead_code)]
        fn bfs_dinic(&self, s: usize) -> Vec<Option<usize>> {
            let mut level = vec![None; self.edges.len()];
            let mut que = VecDeque::new();
            level[s] = Some(0);
            que.push_back(s);
            while !que.is_empty() {
                let v = que.pop_front().unwrap();
                let l = Some(level[v].unwrap() + 1);
                for &(to, cap, _) in &self.edges[v] {
                    if cap > 0 && level[to].is_none() {
                        level[to] = l;
                        que.push_back(to);
                    }
                }
            }
            level
        }
        #[allow(dead_code)]
        fn dfs_dinic(
            &mut self,
            v: usize,
            t: usize,
            f: usize,
            level: &[Option<usize>],
            iter: &mut [usize],
        ) -> usize {
            if v == t {
                return f;
            }
            for i in iter[v]..self.edges[v].len() {
                iter[v] = i;
                let (to, cap, rev) = self.edges[v][i];
                if cap > 0 && level[v].unwrap() < level[to].unwrap_or(0) {
                    let d = self.dfs_dinic(to, t, min(f, cap), level, iter);
                    if d > 0 {
                        self.edges[v][i].1 -= d;
                        self.edges[to][rev].1 += d;
                        return d;
                    }
                }
            }
            0
        }
        #[allow(dead_code)]
        fn max_flow_ff(&mut self, s: usize, t: usize) -> usize {
            let mut flow = 0;
            let l = self.edges.len();
            loop {
                let f = self.dfs_ff(s, t, usize::max_value(), &mut vec![false; l]);
                if f == 0 {
                    break;
                }
                flow += f;
            }
            flow
        }
        #[allow(dead_code)]
        fn dfs_ff(&mut self, v: usize, t: usize, f: usize, used: &mut [bool]) -> usize {
            if v == t {
                return f;
            }
            used[v] = true;
            for i in 0..self.edges[v].len() {
                let (to, cap, rev) = self.edges[v][i];
                if !used[to] && cap > 0 {
                    let d = self.dfs_ff(to, t, min(f, cap), used);
                    if d > 0 {
                        self.edges[v][i].1 -= d;
                        self.edges[to][rev].1 += d;
                        return d;
                    }
                }
            }
            0
        }
        #[allow(dead_code)]
        fn cut(&self, s: usize) -> BTreeSet<usize> {
            let mut stack = Vec::new();
            let mut ss = BTreeSet::new();
            ss.insert(s);
            stack.push(s);
            while !stack.is_empty() {
                let v = stack.pop().unwrap();
                for &(to, cap, _) in &self.edges[v] {
                    if cap > 0 && !ss.contains(&to) {
                        ss.insert(to);
                        stack.push(to);
                    }
                }
            }
            ss
        }
    }

snippet FnvHash
    use std::default::Default;
    use std::hash::{BuildHasherDefault, Hasher};
    #[doc = " An implementation of the Fowler\u{2013}Noll\u{2013}Vo hash function."]
    #[doc = ""]
    #[doc = " See the [crate documentation](index.html) for more details."]
    #[doc = " Ported from [servo/rust-fnv](https://raw.githubusercontent.com/servo/rust-fnv/master/lib.rs)"]
    #[allow(missing_copy_implementations)]
    pub struct FnvHasher(u64);
    impl Default for FnvHasher {
        #[inline]
        fn default() -> FnvHasher {
            FnvHasher(0xcbf29ce484222325)
        }
    }
    impl FnvHasher {
        #[doc = " Create an FNV hasher starting with a state corresponding"]
        #[doc = " to the hash `key`."]
        #[inline]
        pub fn with_key(key: u64) -> FnvHasher {
            FnvHasher(key)
        }
    }
    impl Hasher for FnvHasher {
        #[inline]
        fn finish(&self) -> u64 {
            self.0
        }
        #[inline]
        fn write(&mut self, bytes: &[u8]) {
            let FnvHasher(mut hash) = *self;
            for byte in bytes.iter() {
                hash = hash ^ (*byte as u64);
                hash = hash.wrapping_mul(0x100000001b3);
            }
            *self = FnvHasher(hash);
        }
    }
    #[doc = " A builder for default FNV hashers."]
    pub type FnvBuildHasher = BuildHasherDefault<FnvHasher>;
    #[doc = " A `HashMap` using a default FNV hasher."]
    pub type FnvHashMap<K, V> = HashMap<K, V, FnvBuildHasher>;
    #[doc = " A `HashSet` using a default FNV hasher."]
    pub type FnvHashSet<T> = HashSet<T, FnvBuildHasher>;

snippet HeavyLightDecomposition
    pub struct Tree {
        pub root: usize,
        pub parent: Vec<Option<usize>>,
        pub childs: Vec<Vec<usize>>,
    }
    impl Tree {
        pub fn from_neighbor_list(n: usize, root: usize, g: &[Vec<usize>]) -> Tree {
            let mut parent = vec![None; n];
            let mut childs = vec![Vec::new(); n];
            let mut stack = vec![(root, None)];
            while let Some((i, p)) = stack.pop() {
                parent[i] = p;
                for &to in &g[i] {
                    if Some(to) != p {
                        stack.push((to, Some(i)));
                        childs[i].push(to);
                    }
                }
            }
            Tree {
                root: root,
                parent: parent,
                childs: childs,
            }
        }
    }
    pub struct HeavyLightDecomposition {
        pub ids: Vec<(usize, usize)>,
        pub parents: Vec<Option<(usize, usize)>>,
        pub parts: Vec<Vec<usize>>,
    }
    impl HeavyLightDecomposition {
        pub fn new(tree: &Tree) -> HeavyLightDecomposition {
            fn size(i: usize, tree: &Tree, memo: &mut [Option<usize>]) -> usize {
                if let Some(res) = memo[i] {
                    return res;
                }
                let res = tree.childs[i]
                    .iter()
                    .map(|&to| size(to, tree, memo))
                    .sum::<usize>()
                    + 1;
                memo[i] = Some(res);
                res
            }
            let n = tree.parent.len();
            let root = tree.root;
            let mut memo = vec![None; n];
            let mut ids = vec![(0, 0); n];
            let mut parts: Vec<Vec<usize>> = Vec::new();
            let mut stack = vec![(root, false, None)];
            let mut parents = Vec::new();
            while let Some((i, h, pid)) = stack.pop() {
                if h {
                    let (k, _) = pid.unwrap();
                    ids[i] = (k, parts[k].len());
                    parts[k].push(i);
                } else {
                    ids[i] = (parts.len(), 0);
                    parts.push(vec![i]);
                    parents.push(pid);
                }
                let id = ids[i];
                let heavy = tree.childs[i]
                    .iter()
                    .max_by_key(|&&to| size(to, &tree, &mut memo));
                for &to in &tree.childs[i] {
                    if Some(&to) != heavy {
                        stack.push((to, false, Some(id)));
                    }
                }
                if let Some(&h) = heavy {
                    stack.push((h, true, Some(id)));
                }
            }
            HeavyLightDecomposition {
                ids: ids,
                parents: parents,
                parts: parts,
            }
        }
    }

snippet INF
    #[allow(dead_code)]
    pub const INF: u64 = 1 << 60;

snippet IntervalHeap
    #[doc = " IntervalHeap"]
    #[derive(Clone, Debug)]
    struct IntervalHeap<T: Ord + Eq> {
        data: Vec<T>,
    }
    impl<T: Ord + Eq> IntervalHeap<T> {
        #[allow(dead_code)]
        fn new() -> IntervalHeap<T> {
            IntervalHeap { data: Vec::new() }
        }
        #[allow(dead_code)]
        fn with_capacity(n: usize) -> IntervalHeap<T> {
            IntervalHeap {
                data: Vec::with_capacity(n),
            }
        }
        #[allow(dead_code)]
        #[inline]
        fn len(&self) -> usize {
            self.data.len()
        }
        #[allow(dead_code)]
        #[inline]
        fn is_empty(&self) -> bool {
            self.data.is_empty()
        }
        #[allow(dead_code)]
        #[inline]
        fn push(&mut self, x: T) {
            let i = self.data.len();
            self.data.push(x);
            self.up(i);
        }
        #[allow(dead_code)]
        #[inline]
        fn peek_min(&self) -> Option<&T> {
            self.data.first()
        }
        #[allow(dead_code)]
        #[inline]
        fn peek_max(&self) -> Option<&T> {
            if self.data.len() > 1 {
                self.data.get(1)
            } else {
                self.data.first()
            }
        }
        #[allow(dead_code)]
        #[inline]
        fn pop_min(&mut self) -> Option<T> {
            if self.data.len() == 1 {
                return self.data.pop();
            }
            if self.data.is_empty() {
                return None;
            }
            let len = self.data.len();
            self.data.swap(0, len - 1);
            let res = self.data.pop();
            self.down(0);
            res
        }
        #[allow(dead_code)]
        #[inline]
        fn pop_max(&mut self) -> Option<T> {
            if self.data.len() <= 2 {
                return self.data.pop();
            }
            if self.data.is_empty() {
                return None;
            }
            let len = self.data.len();
            self.data.swap(1, len - 1);
            let res = self.data.pop();
            self.down(1);
            res
        }
        #[allow(dead_code)]
        #[inline]
        fn parent(i: usize) -> usize {
            ((i >> 1) - 1) & !1
        }
        #[allow(dead_code)]
        #[inline]
        fn down(&mut self, i: usize) {
            let mut i = i;
            let n = self.data.len();
            if i & 1 == 0 {
                while (i << 1) + 2 < n {
                    let mut k = (i << 1) + 2;
                    if k + 2 < n
                        && unsafe { self.data.get_unchecked(k + 2) }
                            < unsafe { self.data.get_unchecked(k) }
                    {
                        k = k + 2;
                    }
                    if unsafe { self.data.get_unchecked(i) } > unsafe { self.data.get_unchecked(k) } {
                        self.data.swap(i, k);
                        i = k;
                        if i + 1 < self.data.len()
                            && unsafe { self.data.get_unchecked(i) }
                                > unsafe { self.data.get_unchecked(i + 1) }
                        {
                            self.data.swap(i, i + 1);
                        }
                    } else {
                        break;
                    }
                }
            } else {
                while (i << 1) + 1 < n {
                    let mut k = (i << 1) + 1;
                    if k + 2 < n
                        && unsafe { self.data.get_unchecked(k + 2) }
                            > unsafe { self.data.get_unchecked(k) }
                    {
                        k = k + 2;
                    }
                    if unsafe { self.data.get_unchecked(i) } < unsafe { self.data.get_unchecked(k) } {
                        self.data.swap(i, k);
                        i = k;
                        if i > 0
                            && unsafe { self.data.get_unchecked(i) }
                                < unsafe { self.data.get_unchecked(i - 1) }
                        {
                            self.data.swap(i, i - 1);
                        }
                    } else {
                        break;
                    }
                }
            }
        }
        #[allow(dead_code)]
        #[inline]
        fn up(&mut self, i: usize) {
            let mut i = i;
            if i & 1 == 1
                && unsafe { self.data.get_unchecked(i) } < unsafe { self.data.get_unchecked(i - 1) }
            {
                self.data.swap(i, i - 1);
                i -= 1;
            }
            while i > 1
                && unsafe { self.data.get_unchecked(i) }
                    < unsafe { self.data.get_unchecked(Self::parent(i)) }
            {
                let p = Self::parent(i);
                self.data.swap(i, p);
                i = p;
            }
            while i > 1
                && unsafe { self.data.get_unchecked(i) }
                    > unsafe { self.data.get_unchecked(Self::parent(i) + 1) }
            {
                let p = Self::parent(i) + 1;
                self.data.swap(i, p);
                i = p;
            }
        }
        #[allow(dead_code)]
        #[inline]
        fn clear(&mut self) {
            self.data.clear();
        }
    }
    #[derive(Clone, Debug)]
    struct LimitedIntervalHeap<T: Ord + Eq> {
        heap: IntervalHeap<T>,
        limit: usize,
    }
    impl<T: Ord + Eq> LimitedIntervalHeap<T> {
        #[allow(dead_code)]
        fn new(limit: usize) -> LimitedIntervalHeap<T> {
            LimitedIntervalHeap {
                heap: IntervalHeap::with_capacity(limit),
                limit: limit,
            }
        }
        #[allow(dead_code)]
        #[inline]
        fn is_empty(&self) -> bool {
            self.heap.is_empty()
        }
        #[allow(dead_code)]
        #[inline]
        fn push(&mut self, x: T) -> Option<T> {
            if self.heap.len() < self.limit {
                self.heap.push(x);
                None
            } else {
                if self.heap.data[0] < x {
                    let mut x = x;
                    std::mem::swap(&mut x, &mut self.heap.data[0]);
                    if self.heap.len() >= 2 && self.heap.data[0] > self.heap.data[1] {
                        self.heap.data.swap(0, 1);
                    }
                    self.heap.down(0);
                    Some(x)
                } else {
                    Some(x)
                }
            }
        }
        #[allow(dead_code)]
        #[inline]
        fn pop(&mut self) -> Option<T> {
            self.heap.pop_max()
        }
        #[allow(dead_code)]
        #[inline]
        fn clear(&mut self) {
            self.heap.clear();
        }
    }

snippet LCA
    #[allow(dead_code)]
    pub struct LCA {
        pub depth: Vec<usize>,
        pub parent: Vec<Vec<Option<usize>>>,
    }
    #[allow(dead_code)]
    impl LCA {
        pub fn new(g: &[Vec<usize>]) -> LCA {
            LCA::with_root(0, g)
        }
        pub fn with_root(root: usize, g: &[Vec<usize>]) -> LCA {
            fn dfs(
                i: usize,
                p: Option<usize>,
                d: usize,
                g: &[Vec<usize>],
                depth: &mut [usize],
                parent: &mut [Vec<Option<usize>>],
            ) {
                parent[i][0] = p;
                depth[i] = d;
                for &t in &g[i] {
                    if Some(t) != p {
                        dfs(t, Some(i), d + 1, g, depth, parent);
                    }
                }
            }
            let n = g.len();
            let l2 = (1..).find(|i| 1usize << i > n).unwrap();
            let mut depth = vec![0; n];
            let mut parent = vec![vec![None; l2 + 1]; n];
            dfs(root, None, 0, &g, &mut depth, &mut parent);
            for i in 1..l2 + 1 {
                for j in 0..n {
                    if let Some(p) = parent[j][i - 1] {
                        parent[j][i] = parent[p][i - 1];
                    }
                }
            }
            LCA {
                depth: depth,
                parent: parent,
            }
        }
        pub fn lca(&self, mut a: usize, mut b: usize) -> usize {
            use std::mem::swap;
            if self.depth[b] < self.depth[a] {
                swap(&mut a, &mut b);
            }
            while self.depth[a] != self.depth[b] {
                b = self.parent[b][(self.depth[b] - self.depth[a]).trailing_zeros() as usize].unwrap();
            }
            if a == b {
                return a;
            }
            for i in (0..self.parent[0].len()).rev() {
                if self.parent[a][i] != self.parent[b][i] {
                    a = self.parent[a][i].unwrap();
                    b = self.parent[b][i].unwrap();
                }
            }
            self.parent[a][0].unwrap()
        }
    }

snippet LexicalPermutation
    #[doc = " Ported from [bluss/permutohedron](https://github.com/bluss/permutohedron)"]
    pub trait LexicalPermutation {
        #[doc = " Return \\`true\\` if the slice was permuted, \\`false\\` if it is already"]
        #[doc = " at the last ordered permutation."]
        fn next_permutation(&mut self) -> bool;
        #[doc = " Return \\`true\\` if the slice was permuted, \\`false\\` if it is already"]
        #[doc = " at the first ordered permutation."]
        fn prev_permutation(&mut self) -> bool;
    }
    impl<T> LexicalPermutation for [T]
    where
        T: Ord,
    {
        #[doc = " Original author in Rust: Thomas Backman <serenity@exscape.org>"]
        fn next_permutation(&mut self) -> bool {
            if self.len() < 2 {
                return false;
            }
            let mut i = self.len() - 1;
            while i > 0 && self[i - 1] >= self[i] {
                i -= 1;
            }
            if i == 0 {
                return false;
            }
            let mut j = self.len() - 1;
            while j >= i && self[j] <= self[i - 1] {
                j -= 1;
            }
            self.swap(j, i - 1);
            self[i..].reverse();
            true
        }
        fn prev_permutation(&mut self) -> bool {
            if self.len() < 2 {
                return false;
            }
            let mut i = self.len() - 1;
            while i > 0 && self[i - 1] <= self[i] {
                i -= 1;
            }
            if i == 0 {
                return false;
            }
            self[i..].reverse();
            let mut j = self.len() - 1;
            while j >= i && self[j - 1] < self[i - 1] {
                j -= 1;
            }
            self.swap(i - 1, j);
            true
        }
    }

snippet M
    #[allow(dead_code)]
    pub const M: u64 = 1_000_000_007;

snippet Manacher
    #[allow(dead_code)]
    #[doc = " Manacher's algorithm"]
    pub struct Manacher {
        r: Vec<usize>,
    }
    impl Manacher {
        #[allow(dead_code)]
        pub fn new<T: Eq>(seq: &[T]) -> Manacher {
            let mut r = vec![0; 2 * seq.len() - 1];
            let mut i = 0;
            let mut j = 0;
            while i < r.len() {
                while i >= j && i + j < r.len() && Self::get(seq, i - j) == Self::get(seq, i + j) {
                    j += 1;
                }
                r[i] = j;
                let mut k = 1;
                while i >= k && i + k < r.len() && k + r[i - k] < j {
                    r[i + k] = r[i - k];
                    k += 1;
                }
                i += k;
                j -= k;
            }
            Manacher { r: r }
        }
        #[doc = " [l,r]"]
        #[allow(dead_code)]
        pub fn is_palindrome(&self, l: usize, r: usize) -> bool {
            self.r[l + r] >= r - l + 1
        }
        #[allow(dead_code)]
        fn get<T: Eq>(s: &[T], i: usize) -> Option<&T> {
            if i & 1 == 1 {
                None
            } else {
                s.get(i >> 1)
            }
        }
    }

snippet Monoid-SUM
    #[allow(dead_code)]
    struct SUM;
    impl Monoid for SUM {
        type T = u64;
        fn id() -> Self::T {
            0
        }
        fn op(a: &Self::T, b: &Self::T) -> Self::T {
            *a + *b
        }
    }

snippet RangeAddSum
    #[allow(dead_code)]
    struct RangeAddSum();
    impl SEGimpl for RangeAddSum {
        type Elem = (u64, u64);
        type A = u64;
        type R = u64;
        fn eval(parent: &mut Self::Elem, children: Option<(&mut Self::Elem, &mut Self::Elem)>) {
            let x = parent.1;
            parent.0 += x;
            parent.1 = 0;
            if let Some((c1, c2)) = children {
                c1.1 += x / 2;
                c2.1 += x / 2;
            }
        }
        fn range(x: &Self::A, elem: &mut Self::Elem, l: usize, r: usize) {
            elem.1 += (r - l) as u64 * x;
        }
        fn reduce(parent: &mut Self::Elem, c1: &Self::Elem, c2: &Self::Elem) {
            parent.0 = c1.0 + c2.0;
        }
        fn to_result(elem: Self::Elem) -> Self::R {
            elem.0
        }
    }

snippet RcList
    use std::rc::Rc;
    #[derive(Debug)]
    struct RcListInner<T> {
        parent: RcList<T>,
        value: T,
    }
    #[doc = " O(1) clone, O(1) push"]
    #[derive(Clone, Debug)]
    struct RcList<T>(Option<Rc<RcListInner<T>>>);
    impl<T: Clone> RcList<T> {
        #[allow(dead_code)]
        fn new() -> Self {
            RcList(None)
        }
        #[allow(dead_code)]
        #[inline]
        fn push(&mut self, value: T) {
            *self = RcList(Some(Rc::new(RcListInner {
                parent: self.clone(),
                value,
            })));
        }
        #[allow(dead_code)]
        fn to_vec(&self) -> Vec<T> {
            if let Some(ref inner) = self.0 {
                let mut p = inner.parent.to_vec();
                p.push(inner.value.clone());
                p
            } else {
                Vec::new()
            }
        }
    }

snippet Rev
    #[derive(Eq, PartialEq, Clone, Debug)]
    #[doc = " Equivalent to std::cmp::Reverse"]
    pub struct Rev<T>(pub T);
    impl<T: PartialOrd> PartialOrd for Rev<T> {
        fn partial_cmp(&self, other: &Rev<T>) -> Option<Ordering> {
            other.0.partial_cmp(&self.0)
        }
    }
    impl<T: Ord> Ord for Rev<T> {
        fn cmp(&self, other: &Rev<T>) -> Ordering {
            other.0.cmp(&self.0)
        }
    }

snippet RollingHash
    #[allow(dead_code)]
    #[doc = " Rolling hash algorithm"]
    pub struct RollingHash {
        hash_pow_list: Vec<(u64, Vec<(u64, u64)>)>,
    }
    #[allow(dead_code)]
    impl RollingHash {
        pub fn new(s: &[u64]) -> RollingHash {
            RollingHash::with_base_mod_pairs(s, &[(1009, 1_000_000_007), (9973, 999_999_937)])
        }
        pub fn with_base_mod_pairs(s: &[u64], base_mod_pairs: &[(u64, u64)]) -> RollingHash {
            let hp_list = base_mod_pairs
                .iter()
                .map(|&(base, m)| {
                    let mut hp = Vec::with_capacity(s.len() + 1);
                    hp.push((0, 1));
                    for (i, &x) in s.iter().enumerate() {
                        let (h, p) = hp[i];
                        hp.push(((h + x) * base % m, p * base % m));
                    }
                    (m, hp)
                })
                .collect();
            RollingHash {
                hash_pow_list: hp_list,
            }
        }
        pub fn get(&self, l: usize, r: usize) -> u64 {
            self.hash_pow_list
                .iter()
                .map(|&(m, ref hp)| (hp[r].0 + m - hp[l].0 * hp[r - l].1 % m) % m)
                .fold(0, |a, b| a ^ b)
        }
        pub fn len(&self) -> usize {
            self.hash_pow_list
                .first()
                .map(|v| v.1.len() - 1)
                .unwrap_or(0)
        }
    }

snippet SEG
    #[allow(dead_code)]
    pub trait Monoid {
        type T: Clone;
        fn id() -> Self::T;
        fn op(a: &Self::T, b: &Self::T) -> Self::T;
    }
    #[allow(dead_code)]
    #[doc = " Segment Tree"]
    pub struct SEG<M: Monoid> {
        n: usize,
        buf: Vec<M::T>,
    }
    impl<M: Monoid> SEG<M> {
        #[allow(dead_code)]
        pub fn new(n: usize) -> SEG<M> {
            SEG {
                n: n,
                buf: vec![M::id().clone(); 2 * n],
            }
        }
        #[allow(dead_code)]
        pub fn update(&mut self, k: usize, a: M::T) {
            let mut k = k + self.n;
            self.buf[k] = a;
            while k > 0 {
                k >>= 1;
                self.buf[k] = M::op(&self.buf[k << 1], &self.buf[(k << 1) | 1]);
            }
        }
        #[allow(dead_code)]
        pub fn add(&mut self, k: usize, a: &M::T) {
            let mut k = k + self.n;
            self.buf[k] = M::op(&self.buf[k], a);
            while k > 0 {
                k >>= 1;
                self.buf[k] = M::op(&self.buf[k << 1], &self.buf[(k << 1) | 1]);
            }
        }
        #[allow(dead_code)]
        pub fn get(&self, i: usize) -> M::T {
            self.query(i, i + 1)
        }
        #[allow(dead_code)]
        pub fn query(&self, l: usize, r: usize) -> M::T {
            let mut vl = M::id();
            let mut vr = M::id();
            let mut l = l + self.n;
            let mut r = r + self.n;
            while l < r {
                if l & 1 == 1 {
                    vl = M::op(&vl, &self.buf[l]);
                    l += 1;
                }
                if r & 1 == 1 {
                    r -= 1;
                    vr = M::op(&self.buf[r], &vr);
                }
                l >>= 1;
                r >>= 1;
            }
            M::op(&vl, &vr)
        }
    }

snippet SEG_LAZY
    #[allow(dead_code)]
    #[doc = " Lazy Segment Tree"]
    pub struct SEG<T: SEGimpl> {
        n: usize,
        buf: Vec<T::Elem>,
        zero: T::Elem,
        phantom: std::marker::PhantomData<T>,
    }
    impl<T: SEGimpl> SEG<T> {
        #[allow(dead_code)]
        pub fn new(n: usize, zero: T::Elem) -> SEG<T> {
            let n = (1..).map(|i| 1 << i).find(|&x| x >= n).unwrap();
            SEG {
                n: n,
                buf: vec![zero.clone(); 2 * n],
                zero: zero,
                phantom: std::marker::PhantomData,
            }
        }
        #[allow(dead_code)]
        fn eval(&mut self, k: usize, l: usize, r: usize) {
            if r - l > 1 {
                let (l, r) = self.buf.split_at_mut(2 * k + 1);
                let (c1, c2) = r.split_at_mut(1);
                T::eval(&mut l[k], Some((&mut c1[0], &mut c2[0])));
            } else {
                T::eval(&mut self.buf[k], None);
            }
        }
        #[allow(dead_code)]
        pub fn update(&mut self, i: usize, x: T::Elem) {
            let mut k = i + self.n - 1;
            self.buf[k] = x;
            self.eval(k, i, i + 1);
            while k > 0 {
                k = (k - 1) / 2;
                let (l, r) = self.buf.split_at_mut(2 * k + 1);
                let (c1, c2) = r.split_at_mut(1);
                T::reduce(&mut l[k], &c1[0], &c2[0]);
            }
        }
        #[allow(dead_code)]
        pub fn get(&mut self, i: usize) -> Option<T::R> {
            self.query(i, i + 1)
        }
        #[allow(dead_code)]
        fn r(&mut self, x: &T::A, a: usize, b: usize, k: usize, l: usize, r: usize) {
            self.eval(k, l, r);
            if r <= a || b <= l {
                return;
            }
            if a <= l && r <= b {
                T::range(x, &mut self.buf[k], l, r);
                self.eval(k, l, r);
                return;
            }
            self.r(x, a, b, 2 * k + 1, l, (l + r) / 2);
            self.r(x, a, b, 2 * k + 2, (l + r) / 2, r);
            let (l, r) = self.buf.split_at_mut(2 * k + 1);
            let (c1, c2) = r.split_at_mut(1);
            T::reduce(&mut l[k], &c1[0], &c2[0]);
        }
        #[allow(dead_code)]
        pub fn range_add(&mut self, x: &T::A, a: usize, b: usize) {
            let n = self.n;
            self.r(x, a, b, 0, 0, n);
        }
        #[allow(dead_code)]
        pub fn add(&mut self, x: &T::A, i: usize) {
            self.range_add(x, i, i + 1);
        }
        #[allow(dead_code)]
        fn q(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> Option<T::Elem> {
            self.eval(k, l, r);
            if r <= a || b <= l {
                return None;
            }
            if a <= l && r <= b {
                Some(self.buf[k].clone())
            } else {
                let vl = self.q(a, b, k * 2 + 1, l, (l + r) / 2);
                let vr = self.q(a, b, k * 2 + 2, (l + r) / 2, r);
                match (vl, vr) {
                    (Some(l), Some(r)) => {
                        let mut res = self.zero.clone();
                        T::reduce(&mut res, &l, &r);
                        Some(res)
                    }
                    (Some(l), None) => Some(l),
                    (None, Some(r)) => Some(r),
                    _ => None,
                }
            }
        }
        #[allow(dead_code)]
        pub fn query(&mut self, a: usize, b: usize) -> Option<T::R> {
            let n = self.n;
            self.q(a, b, 0, 0, n).map(T::to_result)
        }
    }
    pub trait SEGimpl {
        type Elem: Clone;
        type A;
        type R;
        fn eval(parent: &mut Self::Elem, children: Option<(&mut Self::Elem, &mut Self::Elem)>);
        fn range(x: &Self::A, elem: &mut Self::Elem, l: usize, r: usize);
        fn reduce(parent: &mut Self::Elem, c1: &Self::Elem, c2: &Self::Elem);
        fn to_result(elem: Self::Elem) -> Self::R;
    }

snippet SkewHeap
    #[derive(Debug, Clone)]
    struct SkewHeapNode<T: Ord> {
        v: T,
        l: SkewHeap<T>,
        r: SkewHeap<T>,
        length: usize,
    }
    #[derive(Debug, Clone)]
    pub struct SkewHeap<T: Ord>(Option<Box<SkewHeapNode<T>>>);
    impl<T: Ord> SkewHeapNode<T> {
        fn swap(&mut self) {
            let &mut SkewHeapNode {
                ref mut l,
                ref mut r,
                ..
            } = self;
            std::mem::swap(l, r);
        }
        fn divide(self) -> (T, SkewHeap<T>, SkewHeap<T>) {
            let SkewHeapNode { v, l, r, .. } = self;
            (v, l, r)
        }
    }
    impl<T: Ord> SkewHeap<T> {
        pub fn new() -> SkewHeap<T> {
            SkewHeap(None)
        }
        pub fn is_empty(&self) -> bool {
            self.0.is_none()
        }
        pub fn len(&self) -> usize {
            self.0.as_ref().map(|n| n.length).unwrap_or(0)
        }
        pub fn meld(&mut self, mut other: SkewHeap<T>) {
            if other.0.is_none() {
                return;
            }
            if self.0.is_none() {
                *self = other;
                return;
            }
            if self.0.as_ref().unwrap().as_ref().v < other.0.as_ref().unwrap().as_ref().v {
                std::mem::swap(self, &mut other);
            }
            if let Some(ref mut node) = self.0.as_mut() {
                node.length += other.0.as_ref().unwrap().length;
                node.r.meld(other);
                node.swap();
            }
        }
        pub fn push(&mut self, x: T) {
            let n = SkewHeap(Some(Box::new(SkewHeapNode {
                v: x,
                l: SkewHeap::new(),
                r: SkewHeap::new(),
                length: 1,
            })));
            self.meld(n);
        }
        pub fn pop(&mut self) -> Option<T> {
            if let Some(node) = self.0.take() {
                let (v, mut l, r) = node.divide();
                l.meld(r);
                *self = l;
                Some(v)
            } else {
                None
            }
        }
        pub fn peek(&self) -> Option<&T> {
            self.0.as_ref().map(|node| &node.v)
        }
    }

snippet Total
    #[derive(PartialEq, PartialOrd)]
    #[doc = " Implement Eq and Ord for a type which has only PartialEq and PartialOrd."]
    #[doc = " It is useful when sorting a Vec of f64"]
    pub struct Total<T>(pub T);
    impl<T: PartialEq> Eq for Total<T> {}
    impl<T: PartialOrd> Ord for Total<T> {
        fn cmp(&self, other: &Total<T>) -> Ordering {
            self.0.partial_cmp(&other.0).unwrap()
        }
    }

snippet Tree
    pub struct Tree {
        pub root: usize,
        pub parent: Vec<Option<usize>>,
        pub childs: Vec<Vec<usize>>,
    }
    impl Tree {
        pub fn from_neighbor_list(n: usize, root: usize, g: &[Vec<usize>]) -> Tree {
            let mut parent = vec![None; n];
            let mut childs = vec![Vec::new(); n];
            let mut stack = vec![(root, None)];
            while let Some((i, p)) = stack.pop() {
                parent[i] = p;
                for &to in &g[i] {
                    if Some(to) != p {
                        stack.push((to, Some(i)));
                        childs[i].push(to);
                    }
                }
            }
            Tree {
                root: root,
                parent: parent,
                childs: childs,
            }
        }
    }

snippet UFT
    #[allow(dead_code)]
    #[doc = " Union Find Tree"]
    pub struct UFT {
        pub par: Vec<usize>,
        pub rank: Vec<usize>,
    }
    impl UFT {
        #[allow(dead_code)]
        pub fn new(n: usize) -> Self {
            UFT {
                par: (0..n).collect(),
                rank: vec![0; n],
            }
        }
        #[allow(dead_code)]
        pub fn root(&mut self, x: usize) -> usize {
            if self.par[x] == x {
                x
            } else {
                let p = self.par[x];
                let pp = self.root(p);
                self.par[x] = pp;
                pp
            }
        }
        #[allow(dead_code)]
        pub fn merge(&mut self, x: usize, y: usize) {
            let x = self.root(x);
            let y = self.root(y);
            if x == y {
                return;
            }
            if self.rank[x] < self.rank[y] {
                self.par[x] = y;
            } else {
                self.par[y] = x;
                if self.rank[x] == self.rank[y] {
                    self.rank[x] += 1;
                }
            }
        }
    }

snippet Vector2D
    #[derive(Debug, Clone, Copy, PartialEq)]
    #[allow(dead_code)]
    pub struct Vector2D(f64, f64);
    impl Vector2D {
        pub fn add(a: f64, b: f64) -> f64 {
            let c = a + b;
            if c.abs() < 1e-10 {
                0.0
            } else {
                c
            }
        }
        pub fn dot(self, other: Vector2D) -> f64 {
            Self::add(self.0 * other.0, self.1 * other.1)
        }
        pub fn det(self, other: Vector2D) -> f64 {
            Self::add(self.0 * other.1, -self.1 * other.0)
        }
        pub fn len(&self) -> f64 {
            f64::sqrt((self.0).powi(2) + (self.1).powi(2))
        }
        pub fn unit(self) -> Vector2D {
            let l = self.len();
            Vector2D(self.0 / l, self.1 / l)
        }
        pub fn normal(self) -> Vector2D {
            Vector2D(self.1, -self.0)
        }
    }
    impl std::ops::Add for Vector2D {
        type Output = Vector2D;
        fn add(self, rhs: Vector2D) -> Self::Output {
            Vector2D(Vector2D::add(self.0, rhs.0), Vector2D::add(self.1, rhs.1))
        }
    }
    impl std::ops::Sub for Vector2D {
        type Output = Vector2D;
        fn sub(self, rhs: Vector2D) -> Self::Output {
            Vector2D(Vector2D::add(self.0, -rhs.0), Vector2D::add(self.1, -rhs.1))
        }
    }
    impl std::ops::Mul<f64> for Vector2D {
        type Output = Vector2D;
        fn mul(self, rhs: f64) -> Self::Output {
            Vector2D(rhs * self.0, rhs * self.1)
        }
    }
    impl std::ops::Div<f64> for Vector2D {
        type Output = Vector2D;
        fn div(self, rhs: f64) -> Self::Output {
            Vector2D(self.0 / rhs, self.1 / rhs)
        }
    }

snippet WeightedUFT
    #[doc = " https://qiita.com/drken/items/cce6fc5c579051e64fab"]
    pub struct WeightedUFT {
        pub par: Vec<usize>,
        pub rank: Vec<usize>,
        pub diff_weight: Vec<i64>,
    }
    impl WeightedUFT {
        pub fn new(size: usize) -> WeightedUFT {
            WeightedUFT {
                par: (0..size).collect(),
                rank: vec![0; size],
                diff_weight: vec![0; size],
            }
        }
        pub fn root(&mut self, x: usize) -> usize {
            if self.par[x] == x {
                x
            } else {
                let p = self.par[x];
                let r = self.root(p);
                self.diff_weight[x] += self.diff_weight[p];
                self.par[x] = r;
                r
            }
        }
        pub fn weight(&mut self, x: usize) -> i64 {
            self.root(x);
            self.diff_weight[x]
        }
        pub fn merge(&mut self, mut x: usize, mut y: usize, mut w: i64) -> bool {
            w += self.weight(x);
            w -= self.weight(y);
            x = self.root(x);
            y = self.root(y);
            if x == y {
                return false;
            }
            if self.rank[x] < self.rank[y] {
                std::mem::swap(&mut x, &mut y);
                w = -w;
            }
            if self.rank[x] == self.rank[y] {
                self.rank[y] += 1;
            }
            self.par[y] = x;
            self.diff_weight[y] = w;
            true
        }
    }

snippet XorShift
    #[derive(Debug)]
    #[allow(dead_code)]
    pub struct Xorshift {
        seed: u64,
    }
    impl Xorshift {
        #[allow(dead_code)]
        pub fn new() -> Xorshift {
            Xorshift {
                seed: 0xf0fb588ca2196dac,
            }
        }
        #[allow(dead_code)]
        pub fn with_seed(seed: u64) -> Xorshift {
            Xorshift { seed: seed }
        }
        #[inline(always)]
        #[allow(dead_code)]
        pub fn next(&mut self) -> u64 {
            self.seed = self.seed ^ (self.seed << 13);
            self.seed = self.seed ^ (self.seed >> 7);
            self.seed = self.seed ^ (self.seed << 17);
            self.seed
        }
        #[inline(always)]
        #[allow(dead_code)]
        pub fn rand(&mut self, m: u64) -> u64 {
            self.next() % m
        }
        #[inline(always)]
        #[allow(dead_code)]
        pub fn randf(&mut self) -> f64 {
            use std::mem;
            const UPPER_MASK: u64 = 0x3FF0000000000000;
            const LOWER_MASK: u64 = 0xFFFFFFFFFFFFF;
            let tmp = UPPER_MASK | (self.next() & LOWER_MASK);
            let result: f64 = unsafe { mem::transmute(tmp) };
            result - 1.0
        }
    }

snippet adjacent4
    #[allow(dead_code)]
    fn adjacent4(x: usize, y: usize, sx: usize, sy: usize) -> Box<Iterator<Item = (usize, usize)>> {
        static DXDY: [(isize, isize); 4] = [(-1, 0), (1, 0), (0, -1), (0, 1)];
        Box::new(DXDY.iter().filter_map(move |&(dx, dy)| {
            let nx = x as isize + dx;
            let ny = y as isize + dy;
            if nx >= 0 && nx < sx as isize && ny >= 0 && ny < sy as isize {
                Some((nx as usize, ny as usize))
            } else {
                None
            }
        }))
    }

snippet adjacent8
    #[allow(dead_code)]
    fn adjacent8(x: usize, y: usize, sx: usize, sy: usize) -> Box<Iterator<Item = (usize, usize)>> {
        static DXDY: [(isize, isize); 8] = [
            (-1, 0),
            (1, 0),
            (0, -1),
            (0, 1),
            (-1, -1),
            (-1, 1),
            (1, -1),
            (1, 1),
        ];
        Box::new(DXDY.iter().filter_map(move |&(dx, dy)| {
            let nx = x as isize + dx;
            let ny = y as isize + dy;
            if nx >= 0 && nx < sx as isize && ny >= 0 && ny < sy as isize {
                Some((nx as usize, ny as usize))
            } else {
                None
            }
        }))
    }

snippet articulation_points
    pub fn articulation_points(g: &[Vec<usize>]) -> Vec<usize> {
        fn dfs(
            i: usize,
            p: usize,
            g: &[Vec<usize>],
            t: usize,
            visited: &mut [bool],
            prenum: &mut [usize],
            parent: &mut [usize],
            lowest: &mut [usize],
        ) {
            prenum[i] = t;
            lowest[i] = t;
            visited[i] = true;
            for &to in &g[i] {
                if !visited[to] {
                    parent[to] = i;
                    dfs(to, i, g, t + 1, visited, prenum, parent, lowest);
                    lowest[i] = min(lowest[i], lowest[to]);
                } else if to != p {
                    lowest[i] = min(lowest[i], prenum[to]);
                }
            }
        }
        let n = g.len();
        let mut visited = vec![false; n];
        let mut prenum = vec![0; n];
        let mut parent = vec![0; n];
        let mut lowest = vec![0; n];
        dfs(
            0,
            0,
            g,
            1,
            &mut visited,
            &mut prenum,
            &mut parent,
            &mut lowest,
        );
        let mut res = if (1..n).filter(|&i| parent[i] == 0).count() >= 2 {
            vec![0]
        } else {
            Vec::new()
        };
        for i in 1..n {
            let p = parent[i];
            if p != 0 && prenum[p] <= lowest[i] {
                res.push(p);
            }
        }
        res.sort();
        res.dedup();
        res
    }

snippet bipartite_matching
    #[allow(dead_code)]
    pub fn bipartite_matching(g: &[Vec<usize>]) -> usize {
        fn dfs(
            v: usize,
            g: &[Vec<usize>],
            mat: &mut [Option<usize>],
            used: &mut [usize],
            id: usize,
        ) -> bool {
            used[v] = id;
            for &u in &g[v] {
                if mat[u].is_none()
                    || used[mat[u].unwrap()] != id && dfs(mat[u].unwrap(), g, mat, used, id)
                {
                    mat[v] = Some(u);
                    mat[u] = Some(v);
                    return true;
                }
            }
            false
        }
        let mut res = 0;
        let mut mat = vec![None; g.len()];
        let mut used = vec![0; g.len()];
        for v in 0..g.len() {
            if mat[v].is_none() {
                if dfs(v, g, &mut mat, &mut used, v + 1) {
                    res += 1;
                }
            }
        }
        res
    }

snippet bridges
    pub fn bridges(g: &[Vec<usize>]) -> Vec<(usize, usize)> {
        fn dfs(
            i: usize,
            p: usize,
            g: &[Vec<usize>],
            t: usize,
            visited: &mut [bool],
            pre: &mut [usize],
            low: &mut [usize],
            res: &mut Vec<(usize, usize)>,
        ) -> usize {
            visited[i] = true;
            pre[i] = t;
            low[i] = t;
            for &to in &g[i] {
                if p != to {
                    if visited[to] {
                        low[i] = min(low[i], low[to]);
                    } else {
                        low[i] = min(low[i], dfs(to, i, g, t + 1, visited, pre, low, res));
                        if low[to] == pre[to] {
                            res.push((i, to));
                        }
                    }
                }
            }
            low[i]
        }
        let n = g.len();
        let mut visited = vec![false; n];
        let mut pre = vec![0; n];
        let mut low = vec![0; n];
        let mut res = Vec::new();
        dfs(0, 0, g, 0, &mut visited, &mut pre, &mut low, &mut res);
        res
    }

snippet closest_pair
    pub fn closest_pair(ps: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {
        fn d(p1: (f64, f64), p2: (f64, f64)) -> f64 {
            ((p1.0 - p2.0).powi(2) + (p1.1 - p2.1).powi(2)).sqrt()
        }
        fn rec(x_sort: &[(f64, f64)], y_sort: &[(f64, f64)]) -> ((f64, f64), (f64, f64)) {
            if x_sort.len() <= 3 {
                let mut min_d = std::f64::MAX;
                let mut pair = ((0.0, 0.0), (0.0, 0.0));
                for (i, &p1) in x_sort.iter().enumerate() {
                    for (j, &p2) in x_sort.iter().enumerate() {
                        if i != j {
                            let dist = d(p1, p2);
                            if dist < min_d {
                                min_d = dist;
                                pair = (p1, p2);
                            }
                        }
                    }
                }
                return pair;
            }
            let mid = x_sort.len() / 2;
            let pivot = x_sort[mid].0;
            let q_x = &x_sort[..mid];
            let r_x = &x_sort[mid..];
            let mut q_y = Vec::with_capacity(mid);
            let mut r_y = Vec::with_capacity(x_sort.len() - mid);
            for &(x, y) in y_sort {
                if x < pivot {
                    q_y.push((x, y));
                } else {
                    r_y.push((x, y));
                }
            }
            let pair1 = rec(q_x, &q_y);
            let pair2 = rec(r_x, &r_y);
            let w = d(pair1.0, pair1.1).min(d(pair2.0, pair2.1));
            let s: Vec<(f64, f64)> = y_sort
                .iter()
                .filter(|&&(x, _)| (pivot - x).abs() <= w)
                .cloned()
                .collect();
            let mut min_d = w;
            let mut pair = if d(pair1.0, pair1.1) < d(pair2.0, pair2.1) {
                pair1
            } else {
                pair2
            };
            for (i, &p1) in s.iter().enumerate() {
                for &p2 in s[i + 1..].iter().take(15) {
                    let dist = d(p1, p2);
                    if dist < min_d {
                        min_d = dist;
                        pair = (p1, p2);
                    }
                }
            }
            pair
        }
        let mut x_sort = ps.to_vec();
        let mut y_sort = ps.to_vec();
        x_sort.sort_by_key(|p| Total(p.0));
        y_sort.sort_by_key(|p| Total(p.1));
        rec(&x_sort, &y_sort)
    }

snippet convex_hull
    #[allow(dead_code)]
    fn convex_hull(vs: &[Vector2D]) -> Vec<usize> {
        let mut idx: Vec<usize> = (0..vs.len()).collect();
        idx.sort_by_key(|&i| Total((vs[i].0, vs[i].1)));
        let mut res = Vec::new();
        for &i in &idx {
            while res.len() > 1
                && Vector2D::det(
                    vs[res[res.len() - 1]] - vs[res[res.len() - 2]],
                    vs[i] - vs[res[res.len() - 1]],
                ) <= 0.0
            {
                res.pop();
            }
            res.push(i);
        }
        let t = res.len();
        for &i in idx.iter().rev().skip(1) {
            while res.len() > t
                && (vs[res[res.len() - 1]] - vs[res[res.len() - 2]]).det(vs[i] - vs[res[res.len() - 1]])
                    <= 0.0
            {
                res.pop();
            }
            res.push(i);
        }
        res.pop();
        res
    }

snippet convex_hull_check
    #[allow(dead_code)]
    #[doc = " A check function for convex hull trick"]
    pub fn convex_hull_check((a1, b1): (i64, i64), (a2, b2): (i64, i64), (a3, b3): (i64, i64)) -> bool {
        (a2 as f64 - a1 as f64) * (b3 as f64 - b2 as f64)
            >= (b2 as f64 - b1 as f64) * (a3 as f64 - a2 as f64)
    }

snippet factor_table
    #[allow(dead_code)]
    pub fn factor_table(max_n: usize) -> Vec<usize> {
        let mut res = vec![0; max_n + 1];
        for i in 2..max_n + 1 {
            if res[i] == 0 {
                let mut j = i;
                while j <= max_n {
                    res[j] = i;
                    j += i;
                }
            }
        }
        res
    }

snippet fib
    #[allow(dead_code)]
    #[doc = " Matrix mul"]
    fn mat_mul2(x: &[u64; 4], y: &[u64; 4], p: u64) -> [u64; 4] {
        [
            (x[0] * y[0] + x[1] * y[2]) % p,
            (x[0] * y[1] + x[1] * y[3]) % p,
            (x[2] * y[0] + x[3] * y[2]) % p,
            (x[2] * y[1] + x[3] * y[3]) % p,
        ]
    }
    #[allow(dead_code)]
    #[doc = " Matrix pow"]
    fn pow_mat(m: &[u64; 4], n: u64, p: u64) -> [u64; 4] {
        let mut m = m.clone();
        let mut res = [1, 0, 1, 0];
        for i in 0.. {
            if n >> i == 0 {
                break;
            }
            if n >> i & 1 == 1 {
                res = mat_mul2(&res, &m, p);
            }
            m = mat_mul2(&m, &m, p);
        }
        res
    }
    #[allow(dead_code)]
    #[doc = " Fast fibonacci calculation"]
    fn fib(i: u64, p: u64) -> u64 {
        let m = pow_mat(&[1, 1, 1, 0], i, p);
        m[1]
    }

snippet is_intersected
    #[doc = " Is line a-b and line c-d intersected ?"]
    pub fn is_intersected(a: Vector2D, b: Vector2D, c: Vector2D, d: Vector2D) -> bool {
        let ta = (c.0 - d.0) * (a.1 - c.1) + (c.1 - d.1) * (c.0 - a.0);
        let tb = (c.0 - d.0) * (b.1 - c.1) + (c.1 - d.1) * (c.0 - b.0);
        let tc = (a.0 - b.0) * (c.1 - a.1) + (a.1 - b.1) * (a.0 - c.0);
        let td = (a.0 - b.0) * (d.1 - a.1) + (a.1 - b.1) * (a.0 - d.0);
        tc * td <= 0.0 && ta * tb <= 0.0
    }

snippet lis
    #[doc = " Equivalent to std::lowerbound and std::upperbound in c++"]
    pub trait BinarySearch<T> {
        fn lower_bound(&self, x: &T) -> usize;
        fn upper_bound(&self, x: &T) -> usize;
    }
    impl<T: Ord> BinarySearch<T> for [T] {
        fn lower_bound(&self, x: &T) -> usize {
            let mut low = 0;
            let mut high = self.len();
            while low != high {
                let mid = (low + high) / 2;
                match self[mid].cmp(x) {
                    Ordering::Less => {
                        low = mid + 1;
                    }
                    Ordering::Equal | Ordering::Greater => {
                        high = mid;
                    }
                }
            }
            low
        }
        fn upper_bound(&self, x: &T) -> usize {
            let mut low = 0;
            let mut high = self.len();
            while low != high {
                let mid = (low + high) / 2;
                match self[mid].cmp(x) {
                    Ordering::Less | Ordering::Equal => {
                        low = mid + 1;
                    }
                    Ordering::Greater => {
                        high = mid;
                    }
                }
            }
            low
        }
    }
    #[derive(PartialEq, Eq, Clone, Debug)]
    enum Inf<T> {
        Val(T),
        Inf,
    }
    impl<T: Ord> Inf<T> {
        #[allow(dead_code)]
        fn val(self) -> Option<T> {
            match self {
                Inf::Val(v) => Some(v),
                _ => None,
            }
        }
    }
    impl<T: PartialOrd> PartialOrd for Inf<T> {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            match (self, other) {
                (&Inf::Inf, &Inf::Inf) => Some(Ordering::Equal),
                (&Inf::Inf, &Inf::Val(_)) => Some(Ordering::Greater),
                (&Inf::Val(_), &Inf::Inf) => Some(Ordering::Less),
                (&Inf::Val(ref a), &Inf::Val(ref b)) => a.partial_cmp(b),
            }
        }
    }
    impl<T: Ord> Ord for Inf<T> {
        fn cmp(&self, other: &Self) -> Ordering {
            match (self, other) {
                (&Inf::Inf, &Inf::Inf) => Ordering::Equal,
                (&Inf::Inf, &Inf::Val(_)) => Ordering::Greater,
                (&Inf::Val(_), &Inf::Inf) => Ordering::Less,
                (&Inf::Val(ref a), &Inf::Val(ref b)) => a.cmp(b),
            }
        }
    }
    #[allow(dead_code)]
    #[doc = " Calculate length of Longest Increasing Subsequence. O(N log N)"]
    pub fn lis<T: Ord>(seq: &[T]) -> usize {
        let mut dp: Vec<Inf<&T>> = vec![Inf::Inf; seq.len() + 1];
        for x in seq.iter() {
            let i = dp.lower_bound(&Inf::Val(x));
            dp[i] = Inf::Val(x);
        }
        dp.lower_bound(&Inf::Inf)
    }

snippet mat_mul2
    #[allow(dead_code)]
    #[doc = " Matrix mul"]
    fn mat_mul2(x: &[u64; 4], y: &[u64; 4], p: u64) -> [u64; 4] {
        [
            (x[0] * y[0] + x[1] * y[2]) % p,
            (x[0] * y[1] + x[1] * y[3]) % p,
            (x[2] * y[0] + x[3] * y[2]) % p,
            (x[2] * y[1] + x[3] * y[3]) % p,
        ]
    }

snippet mod
    #[allow(dead_code)]
    pub fn gcd(a: u64, b: u64) -> u64 {
        if b == 0 {
            a
        } else {
            gcd(b, a % b)
        }
    }
    #[allow(dead_code)]
    pub fn lcm(a: u64, b: u64) -> u64 {
        a / gcd(a, b) * b
    }
    #[allow(dead_code)]
    #[doc = " (gcd, x, y)"]
    pub fn extgcd(a: i64, b: i64) -> (i64, i64, i64) {
        if b == 0 {
            (a, 1, 0)
        } else {
            let (gcd, x, y) = extgcd(b, a % b);
            (gcd, y, x - (a / b) * y)
        }
    }
    #[allow(dead_code)]
    #[doc = " x ^ n % m"]
    pub fn mod_pow(x: u64, n: u64, m: u64) -> u64 {
        let mut res = 1;
        let mut x = x % m;
        let mut n = n;
        while n > 0 {
            if n & 1 == 1 {
                res = (res * x) % m;
            }
            x = (x * x) % m;
            n >>= 1;
        }
        res
    }
    #[allow(dead_code)]
    pub fn mod_inverse(a: u64, m: u64) -> u64 {
        let (_, x, _) = extgcd(a as i64, m as i64);
        ((m as i64 + x) as u64 % m) % m
    }
    #[allow(dead_code)]
    pub fn fact_table(len: usize, m: u64) -> Vec<u64> {
        let mut res = vec![1; len + 1];
        for i in 1..len + 1 {
            res[i] = (i as u64 * res[i - 1]) % m;
        }
        res
    }
    #[allow(dead_code)]
    #[doc = " Factorial and Inverse factorial table"]
    pub fn fact_inv_table(size: usize, m: u64) -> (Vec<u64>, Vec<u64>) {
        let mut fact = vec![1; size];
        let mut fact_inv = vec![1; size];
        for i in 2..size {
            fact[i] = fact[i - 1] * i as u64 % m;
            fact_inv[i] = m - ((m / i as u64) * fact_inv[(m % i as u64) as usize] % m);
        }
        for i in 1..size {
            fact_inv[i] = fact_inv[i - 1] * fact_inv[i] % m;
        }
        (fact, fact_inv)
    }
    #[allow(dead_code)]
    #[doc = " (a mod p, e when n! = a p\\^e)"]
    pub fn mod_fact(n: u64, p: u64, fact: &[u64]) -> (u64, u64) {
        if n == 0 {
            (1, 0)
        } else {
            let (a, b) = mod_fact(n / p, p, fact);
            let pow = b + n / p;
            if n / p % 2 != 0 {
                (a * (p - fact[(n % p) as usize]) % p, pow)
            } else {
                (a * fact[(n % p) as usize] % p, pow)
            }
        }
    }
    #[allow(dead_code)]
    #[doc = " C(n, k) % p"]
    pub fn mod_comb(n: u64, k: u64, p: u64, fact: &[u64]) -> u64 {
        if n < k {
            0
        } else {
            let (a1, e1) = mod_fact(n, p, fact);
            let (a2, e2) = mod_fact(k, p, fact);
            let (a3, e3) = mod_fact(n - k, p, fact);
            if e1 > e2 + e3 {
                0
            } else {
                a1 * mod_inverse(a2 * a3 % p, p) % p
            }
        }
    }
    #[allow(dead_code)]
    #[doc = " H(n, k) % p"]
    pub fn mod_comb_repetition(n: u64, k: u64, p: u64, fact: &[u64]) -> u64 {
        mod_comb(n - 1 + k, n - 1, p, fact)
    }

snippet nck_prob
    #[allow(dead_code)]
    #[doc = " v[n][k] = nCk / 2^n"]
    fn nck_prob(n: usize) -> Vec<Vec<f64>> {
        let mut res = vec![vec![1.0]];
        for _ in 1..n {
            let mut v = Vec::new();
            {
                let last = res.last().unwrap();
                v.push(last.first().unwrap() / 2.0);
                for i in 0..last.len() - 1 {
                    v.push((last[i] + last[i + 1]) / 2.0);
                }
                v.push(last.last().unwrap() / 2.0);
            }
            res.push(v);
        }
        res
    }

snippet partition_dp
    #[allow(dead_code)]
    #[doc = " dp[i][j] = j th partition number of i"]
    pub fn partition_dp(n: usize, m: usize, p: u64) -> Vec<Vec<u64>> {
        let mut dp = vec![vec![0; m + 1]; n + 1];
        for i in 0..m + 1 {
            dp[0][i] = 1;
        }
        for i in 1..n + 1 {
            for j in 1..m + 1 {
                if i >= j {
                    dp[i][j] = (dp[i - j][j] + dp[i][j - 1]) % p;
                } else {
                    dp[i][j] = dp[i][j - 1];
                }
            }
        }
        dp
    }

snippet pow_mat
    #[allow(dead_code)]
    #[doc = " Matrix pow"]
    fn pow_mat(m: &[u64; 4], n: u64, p: u64) -> [u64; 4] {
        let mut m = m.clone();
        let mut res = [1, 0, 1, 0];
        for i in 0.. {
            if n >> i == 0 {
                break;
            }
            if n >> i & 1 == 1 {
                res = mat_mul2(&res, &m, p);
            }
            m = mat_mul2(&m, &m, p);
        }
        res
    }

snippet strongly_connected_component
    #[allow(dead_code)]
    pub fn strongly_connected_component(g: &[Vec<usize>]) -> Vec<usize> {
        fn dfs(v: usize, g: &[Vec<usize>], vs: &mut Vec<usize>, used: &mut [bool]) {
            used[v] = true;
            for &to in &g[v] {
                if !used[to] {
                    dfs(to, g, vs, used);
                }
            }
            vs.push(v);
        }
        fn rdfs(v: usize, k: usize, g_rev: &[Vec<usize>], cmp: &mut [usize], used: &mut [bool]) {
            used[v] = true;
            cmp[v] = k;
            for &to in &g_rev[v] {
                if !used[to] {
                    rdfs(to, k, g_rev, cmp, used);
                }
            }
        }
        let g_rev = {
            let mut g_rev = vec![Vec::new(); g.len()];
            for (i, es) in g.iter().enumerate() {
                for &to in es {
                    g_rev[to].push(i);
                }
            }
            g_rev
        };
        let mut vs = Vec::new();
        let mut used = vec![false; g.len()];
        for v in 0..g.len() {
            if !used[v] {
                dfs(v, g, &mut vs, &mut used);
            }
        }
        let mut used = vec![false; g.len()];
        let mut cmp = vec![0; g.len()];
        let mut k = 0;
        for &v in vs.iter().rev() {
            if !used[v] {
                rdfs(v, k, &g_rev, &mut cmp, &mut used);
                k += 1;
            }
        }
        cmp
    }

snippet template
    #[doc = " https://github.com/hatoo/competitive-rust-snippets"]
    #[allow(unused_imports)]
    use std::cmp::{max, min, Ordering};
    #[allow(unused_imports)]
    use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
    #[allow(unused_imports)]
    use std::io::{stdin, stdout, BufWriter, Write};
    #[allow(unused_imports)]
    use std::iter::FromIterator;
    mod util {
        use std::fmt::Debug;
        use std::io::{stdin, stdout, BufWriter, StdoutLock};
        use std::str::FromStr;
        #[allow(dead_code)]
        pub fn line() -> String {
            let mut line: String = String::new();
            stdin().read_line(&mut line).unwrap();
            line.trim().to_string()
        }
        #[allow(dead_code)]
        pub fn chars() -> Vec<char> {
            line().chars().collect()
        }
        #[allow(dead_code)]
        pub fn gets<T: FromStr>() -> Vec<T>
        where
            <T as FromStr>::Err: Debug,
        {
            let mut line: String = String::new();
            stdin().read_line(&mut line).unwrap();
            line.split_whitespace()
                .map(|t| t.parse().unwrap())
                .collect()
        }
        #[allow(dead_code)]
        pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {
            let out = stdout();
            let writer = BufWriter::new(out.lock());
            f(writer)
        }
    }
    #[allow(unused_macros)]
    macro_rules ! get { ( [ $ t : ty ] ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( [ $ t : ty ] ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( [ $ t ] ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; }
    #[allow(unused_macros)]
    macro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , " = {:?}, " ) ,* ) , $ ( $ a ) ,* ) ; } }
    const BIG_STACK_SIZE: bool = true;
    #[allow(dead_code)]
    fn main() {
        use std::thread;
        if BIG_STACK_SIZE {
            thread::Builder::new()
                .stack_size(32 * 1024 * 1024)
                .name("solve".into())
                .spawn(solve)
                .unwrap()
                .join()
                .unwrap();
        } else {
            solve();
        }
    }
    fn solve() {}

snippet attest
    macro_rules! test {
        ($($input:expr => $output:expr),* $(,)*) => {
            #[test]
            fn solve_test() {
                $(
                    assert_eq!(solve($input), $output);
                )*
            }
        };
    }

snippet atcoder
  #[allow(unused_imports)]
  use std::cmp::*;
  #[allow(unused_imports)]
  use std::collections::*;
  #[allow(unused_imports)]
  use std::iter::*;
  #[allow(unused_imports)]
  use std::*;

  macro_rules! test {
      ($($input:expr => $output:expr),* $(,)*) => {
          #[test]
          fn solve_test() {
              $(
                  assert_eq!(solve($input), $output);
              )*
          }
      };
  }
  macro_rules! input {
      (source = $s:expr, $($r:tt)*) => {
          let mut iter = $s.split_whitespace();
          input_inner!{iter, $($r)*}
      };
      ($($r:tt)*) => {
          let mut s = {
              use std::io::Read;
              let mut s = String::new();
              std::io::stdin().read_to_string(&mut s).unwrap();
              s
          };
          let mut iter = s.split_whitespace();
          input_inner!{iter, $($r)*}
      };
  }

  macro_rules! input_inner {
      ($iter:expr) => {};
      ($iter:expr, ) => {};

      ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {
          let mut $var = read_value!($iter, $t);
          input_inner!{$iter $($r)*}
      };
  }

  macro_rules! read_value {
      ($iter:expr, ( $($t:tt),* )) => {
          ( $(read_value!($iter, $t)),* )
      };

      ($iter:expr, [ $t:tt ; $len:expr ]) => {
          (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()
      };

      ($iter:expr, chars) => {
          read_value!($iter, String).chars().collect::<Vec<char>>()
      };

      ($iter:expr, usize1) => {
          read_value!($iter, usize) - 1
      };

      ($iter:expr, $t:ty) => {
          $iter.next().unwrap().parse::<$t>().expect("Parse error")
      };
  }

  macro_rules! stdin {
      () => {{
          use std::io::Read;
          let mut s = String::new();
          std::io::stdin().read_to_string(&mut s).unwrap();
          s
      }};
  }

  fn main() {
      println!("{}", solve(&stdin!()));
  }
  fn solve(src: &str) -> String {
      input! {
          source = src,
          s:String,
      }
      if let Ok(num) = s.parse::<i32>() {
          (num * 2).to_string()
      } else {
          "error".to_string()
      }
  }
  test! {
      "678" => "1356",
      "abc" => "error",
      "0x8" => "error"
  }
